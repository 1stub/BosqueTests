%%
%% This is a Bosque implementation of binary-trees from https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/binarytrees-graalvmaot-7.html
%%

declare namespace Main;

const min_depth: Nat = 4n;

datatype Tree of
| Node { left: Tree, right: Tree }
| Empty {}
;

function bottomUpTree(depth: Nat): Tree {
    return if(depth > 0n)
        then Node{ bottomUpTree(depth - 1n), bottomUpTree(depth - 1n) }
        else Empty{};
}

recursive function itemCheck(t: Tree): Nat {
    match(t)@ {
        |Node  => { return 1n + itemCheck($t.left) + itemCheck($t.right); }
        |Empty => { return 1n; }
    }
}

function executeDepths(currentDepth: Nat, maxDepth: Nat, absoluteMaxDepth: Nat, acc: List<CString>): List<CString> {
    if(currentDepth > maxDepth) {
        return acc;
    }

    %% Need a pow op here
    let iterations = Nat::pow(2n, (absoluteMaxDepth - currentDepth + min_depth));
    let check = processTrees(currentDepth, iterations, 0n);

    let eit = iterations.toCString();
    let ed = currentDepth.toCString();
    let echk = check.toCString();
    let res = CString::concat(eit, ' trees of depth ', ed, ' check: ', echk);

    return executeDepths[recursive](currentDepth + 2n, maxDepth, absoluteMaxDepth, acc.pushBack(res));
}

recursive function processTrees(depth: Nat, iterations: Nat, current: Nat): Nat {
    if(current >= iterations) {
        return 0n;
    }

    let tree = bottomUpTree(depth);
    let check = itemCheck(tree);
    return check + processTrees(depth, iterations, current + 1n);
}

public function main(): Nat {
    let n = 12n;
    let maxDepth = if(n < min_depth + 2n) 
        then min_depth + 2n 
        else n;
    let stretchDepth = maxDepth + 1n;

    %% We dont have any way to prNat results for cpp runtime yet
    let stretchTree = bottomUpTree(stretchDepth);
    let stretchCheck = itemCheck(stretchTree);

    let longLivedTree = bottomUpTree(maxDepth);

    let results = executeDepths(min_depth, maxDepth, maxDepth, List<CString>{});
    
    let longLivedCheck = itemCheck(longLivedTree);

    return stretchCheck + longLivedCheck + results.size();
}